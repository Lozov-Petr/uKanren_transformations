\section{Directed relational conjunction}

% В этом разделе мы рассмотрим реляционный язык miniKanren с классической направленной конъюнкцией, изучим достоинства и недостатки направленной конъюнкции на примерах.
In this section we consider the relational language \mk~ with the classic directed conjunction and demonstrate the advantages and disadvantages of directed conjunction using examples. 

% В языке miniKanren между операциями дизъюнкции и конъюнкции есть существенная разница. Дизъюнкция вычисляет свои аргументы попеременно, что приводит к равномерному вычислению двух дизъюнктов. Такого поведения дизъюнкции достаточно для полного поиска ответов. Конъюнкция же извлекает ответы из первого конъюнкта, на которых вычисляет второй конъюнкт. С одной стороны, такая конъюнкция проста в реализации и позволяет явно задать порядок исполнения конъюнктов. С другой стороны, эта конъюнкция ассиметрична. Более того, она может сходиться при одном порядке конъюнктов, но расходиться при другом. Например, отнонение freeze в зависимости от аргумента либо сходится за один шаг рекурсии, либо расходится. Тогда конъюнкция вида (=== /\ freeze) сходится, но при перестановке конъюнктов мы получаем расхождение. Действительно, в первом случае первый конъюнкт производит ровно один ответ, который противоречит унификации в теле отношения freeze. Во втором случае отношение freeze разойдется и не произведет ни одного ответа и второй конъюнкт вычислен не будет. 
In classic \mk, there is a significant difference between disjunction and conjunction operations. 
The disjunction evaluates its arguments alternately, which leads to the uniform evaluation of two disjuncts. 
This behavior is enough to fully search for answers. 
The conjunction, on the other hand, extracts the answers from the first conjunct and it calculates the second conjunct using this answers.
On the one hand, this conjunction is easy to implement and allows you to explicitly specify the order of evaluation of the conjuncts.
On the other hand, this conjunction is asymmetric. 
Moreover, it can converge in one order of conjuncts, but diverge in another.
For example, relation
\begin{lstlisting}
let rec freeze$^o$ x = x ===  true /\ freeze$^o$ x
\end{lstlisting}
either converges in one recursion step or diverges.
Then conjunction \lstinline{(x === false/\ freeze$^o$ x)} converges, but conjunction with the reverse order of conjuncts \lstinline{(freeze$^o$ x /\ x === false)} diverges.
Indeed, in the first case, the first conjunct produces exactly one answer, which contradicts the unification in the body of the relation \lstinline{freeze$^o$}. In the second case, the relation \lstinline{freeze$^o$} diverges and isn't produce any answer. As a result, the second conjunct will not be evaluated.

% Конечно, данная проблема решается правилом, которому нужно следовать при работе с miniKanren: унификацию нужно ставить самым левым конъюнктом. Но иногда оба конъюнктв являются вызовами отношений. В частности отношение обращения списка revers, которое связывает произвольный список со списком, содержащим элементы в обратном порядке. В этом отношении есть пара конъюнктов append и revers. При таком порядке вызов revers сходится, но при обратном порядке он расходится. Более того при обратном порядке снижается скорость вычисления ответа. 
Of course, this problem can be solved by the rule that must be followed when working with \mk: unification must be the left-most conjunct.
But sometimes both conjuncts are calls of relations.
For instance, the relation \lstinline{revers$^o$} in figure~\ref{fair:lst-reverso}, which associates an arbitrary list with a list containing elements in reverse order.
In this relation we can see a couple of conjuncts: \lstinline{revers$^o$} in line~\ref{fair:reverso-call} and \lstinline{append$^o$} in line~\ref{fair:appendo-call}. In this order, the call \lstinline{(revers$^o$ [1, 2, 3] q)} converges, but in the reverse order it diverges after the answer is found. Moreover, the reverse order decreases the speed of evaluating the answer.

\begin{figure}[h]
\centering
\begin{tabular}{cp{3cm}c}
\begin{lstlisting}[numbers=left,numberstyle=\small]
let rec append$^o$ x y xy =
  (x === [] /\ y === xy) \/
  fresh (e xs xys) (
    x === e : xs /\ 
    xs === e : xys /\ 
    append$^o$ xs y xys)
\end{lstlisting}
& &
\begin{lstlisting}[firstnumber=7,numbers=left,numberstyle=\small,escapeinside={@}{@}]
let rec revers$^o$ x y =
  (x === [] /\ y === []) \/
  fresh (e xs ys) (
    x === e : xs /\ 
@\label{fair:reverso-call}@    revers$^o$ xs ys /\
@\label{fair:appendo-call}@    append$^o$ ys [e] y)
\end{lstlisting}
\end{tabular}

\caption{Relational program to list reversing}
\label{fair:lst-reverso}
\end{figure}

% В то же время, вызов revers при заданном порядке конъюнктов расходится, а при обратном сходится. В результате мы бы хотели разный порядок конъюнктов в зависимости от конкретных аргументов.

At the same time, the call \lstinline{(revers$^o$ q [1, 2, 3])} for a given order of conjuncts diverges, and for the reverse order it converges. As a result, we would like a different order of conjuncts depending on specific arguments.

% В следующих разделах мы предлжожим подход, который будет определять оптимальный порядок автоматически во время исполнения программы.
In the following sections, we propose an approach that will determine the optimal order automatically during program evaluation.